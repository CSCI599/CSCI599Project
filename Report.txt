Setup:

Git Repository link: https://github.com/CSCI599/CSCI599Project
Java version: 7
External libraries: BCEL, Cobertura (along with any other dependency they might have).

Running:

The java file MainClass.java is the starting point of the analysis.

It expects 4 arguments:

1. Line number to run
2. Path to class file
3. Name of class file (without .class extension)
4. Name of the method

Understanding the output:

The output contains: 

1) Total nodes in the CFG
2) Number of nodes which can reach the given line number
3) Conditions that the line number depends on 
4) Some detailed information about the conditions like source line number, variable and its expected value etc.


Approach:

1) Prepare CFG and reachability information (similar to the ICAs)
2) Find the conditions (IF statements in byte code) on which a particular node depends on. This is done as follows:

* Find all branch statements that can reach the given node.
* The above set of branch statements may contain several conditions which do not affect the node we want to execute. There were two scenarios that we thought of:

I Always executed conditions

(i) Lets say statements B1, B2, ...., Bn are branch statements that can reach node N.
(ii) N is a child of node Bn.
(iii) The flow is such that node Bn will always be executed.
(iv) In this case even though B1...Bn-1 can reach N, the execution of N depends only on node Bn. 
So we remove all branches before Bn from the set of branches that can affect N.

II Paths that always reach a given node.

(i) Lets say we want to execute a node N.
(ii) The location of N in the CFG is such that all paths will eventually reach it. In this case N is independent of any condition.
(iii) We can extend the above logic to determine the sub branches that N may be independent of:
Assume that branch B1 has two children: B2, B3.
B3 itself has two children: B4, B5.
Both B4 and B5 terminate at node N.
Here we can see that all paths from B3 will eventually reach N. So N is independent of B3.
However, N is not independent of B1.

Using this approach we determined the conditions on which a given node depends on.

3) The next step is to determine the variables on which a given condition depends on. 
This is a complex step in terms of determining the value that a condition expects to be true. 
This is because there can be different types of IF comparisons involving different types of data types.
We concentrated on baisc integer and string comparisons.
From the byte code, we determined the instructions that were loaded befor the IF statement.
These instructions load the variables and constants required for the comparison.
From the LocalVariableTable we determine the name and value of these variables.

4) calculate reaching definition: Verify that the variable is obtained from "outside" and is not modified within the code.
If it is modified, mark the variable.
For each node in the graph, we compute the reaching definitions. This iterative algorithm is used to compute reaching definition:

// Boundary condition
out[Entry] = ∅

// Initialization for iterative algorithm For each basic block B other than Entry
For each basic block B other than Entry {
	out[B] = ∅
	gen[B] = {d} // gen of B is definition(s) generated in block B (could be ∅ if B does not contain defintion
	kill[B] = set of all other defs in the rest of program to the variable(s) defined in B
}

// iterate
While (Changes to any out[] occur) {
	For each basic block B other than Entry {
		in[B] = ∪ (out[p]), for all predecessors p of B
		out[B]=gen[B] ∪ (in[B]-kill[B])
	}
}

5) Print output: Print the line numbers, conditions, variables (and their expected value if possible) that the given node depends on.
If the variable was "Marked" in the reaching definition as modified in the code, display a message saying that the variable was modified in the code (with the line number where it was modified).
